/*
* Go Library (C) 2017 Inc.
*
* @project     FileServer
* @package     main
* @author      @jeffotoni
* @size        23/09/2018
*
* @description Our route is responsible for making routes
* and defining authentication in the handlers and determining
* access permissions, we use jwt to generate the tokens and
* authorize the use of api.
*
* $ openssl genrsa -out private.rsa 1024
* $ openssl rsa -in private.rsa -pubout > public.rsa.pub
*
* All the handlers to be accessed are authenticated in some way with
* the token hash generated by our backend and made available on the
* front end so that the site can communicate with the api.
* For the use of api, it will only be allowed for accounts registered in the platform
* and will receive key_access and token_access.
*
 */

package config

import (
	"fmt"
	"github.com/github.com/jeffotoni/fileserver/pkg/gcolor"
	"net/http"
)

var (
	confServer *http.Server

	CorsAllow = []string{"http://localhost", "http://localhost/example", "http://localhost:3000"}

	CorsAllowedMethods = []string{"HEAD", "GET", "POST", "PUT", "PATCH", "DELETE"}

	CorsAllowedHeaders = []string{"*"}
)

const (
	_      = iota
	KB int = 1 << (10 * iota)
	MB int = 100 << (10 * iota)
	GB int = 1000 << (10 * iota)

	Protocol = "http://"

	ServerPort = "5000"

	Schema = "localhost"

	HttpHeaderMsg = `Good FileServer, obrigado!`

	MaxHeaderByte = GB

	NewLimiter = 10000 // 100 requests per second

	//
	// Testing our handlers public
	//
	// POST
	HandlerPing = "/v1/test/ping"

	//
	// Private handler
	//
	// POST
	HandlerHello = "/v1/test/hello"

	// The login of the api, to work needs the access keys key_access and token_access,
	// that is the user registered in the platform will have the two keys available
	// to use the apis of the platform
	// POST
	HandlerLogin = "/v1/user/login"

	// Will be responsible for creating new account on the platform,
	// to use this handler requires the KEY_ACESS AND TOKEN_ACESS
	// You can only use the api if you have these 2 fields, only
	// these 2 fields will have the users that register in the SITE.
	// You will receive a post with the fields to create the user
	// and validate login / email and their respective fields.
	// HandlerCreateUser = "/create/user"
	// POST
	HandlerCreateUser = "/v1/user"

	// It is responsible for allowing the sending of files to the server, to use these handler the user will have to have the token sent at the moment of login.
	// The header is used "Authorization: Bearer <token>" to allow sending.
	// The upload will be accepted multipart / form-data for single or multiple sending with multiple option.
	// Example in cURL would be -F | --form
	// The upload will also not accept the possibility of loading binary files at the first moment,
	// ie the cURL --data-binary option will not be allowed, due to the control limitations imposed by the protocol.
	// Example in cURL would be --data-binary
	//HandlerUpload = "/upload"
	// POST
	HandlerUpload = "/v1/file/upload"

	// the download will be done
	// from the physical disk or
	// the cloud storage
	// managed by java
	// GET
	HandlerDownload = "/v1/file/download"

	// handler remove file, was set logically in the trash column warning the system
	// that it can no longer display the file on the screen, it went to the trash
	// HandlerUploadRemoveDefinitive = "/file/remove/definitive"
	// DELETE
	HandlerUploadRemoveDefinitive = "/v1/file"

	// only users of type admin or level 5
	// can enable and disable users,
	// the tokem is validated
	// to check the permission
	// POST
	HandlerDisableUser = "/v1/user/disable"

	// only users of type admin or level 5
	// can enable and disable users,
	// the tokem is validated
	// to check the permission
	// POST
	HandlerEnableUser = "/v1/user/enable"

	//
	//
	//
	// POST
	HandlerConfirmEmail = "/v1/user/confirm_email"

	//
	//
	//
	HttpConfirmEmail = Protocol + Schema + ":" + ServerPort + "" + HandlerConfirmEmail

	//
	//
	//
	HttpRestoreAccount = Protocol + Schema + ":" + ServerPort + "" + HandlerRestoreAccount
)

//
// Type responsible for defining a function that returns boolean
//
type fn func(w http.ResponseWriter, r *http.Request) bool

type Adapter func(http.Handler) http.Handler

// Adapt h with all specified adapters.
func Adapt(h http.Handler, adapters ...Adapter) http.Handler {
	for _, adapter := range adapters {
		h = adapter(h)
	}
	return h
}

//
// Function responsible for abstraction and receive the
// authentication function and the handler that will execute if it is true
//
func HandlerFuncAuth(auth fn, handler http.HandlerFunc) http.HandlerFunc {

	return func(w http.ResponseWriter, r *http.Request) {

		if auth(w, r) {

			handler(w, r)

		} else {

			HandlerError(w, r)
		}
	}
}

//
// Screen Logo
//
func ShowScreenMain() {

	fmt.Println(LOGO_FILESERVER)
}

//
// Mounting the properties on the api screen
//
func ShowScreen() {

	//
	// Basic Authentication
	//
	Login := Protocol + Schema + ":" + ServerPort + "" + HandlerLogin

	//
	//
	//
	Ping := Protocol + Schema + ":" + ServerPort + "" + HandlerPing

	//
	//
	//
	Hello := Protocol + Schema + ":" + ServerPort + "" + HandlerHello

	//
	// Basic Authentication, handler
	//
	CreateUser := Protocol + Schema + ":" + ServerPort + "" + HandlerCreateUser

	//
	// Basic Authentication, handler
	//
	Upload := Protocol + Schema + ":" + ServerPort + "" + HandlerUpload

	//
	//
	//
	Download := Protocol + Schema + ":" + ServerPort + "" + HandlerDownload

	//
	// HandlerDisableUser
	//
	DisableUser := Protocol + Schema + ":" + ServerPort + "" + HandlerDisableUser

	//
	// HandlerDisableUser
	//
	EnableUser := Protocol + Schema + ":" + ServerPort + "" + HandlerEnableUser

	//
	//
	//
	sizeMb := MaxHeaderByte

	//
	//
	//
	SizeString := fmt.Sprint("Max bytes: ", sizeMb, " Giga")

	// [GIN-debug] POST   /v1/login                 --> main.loginEndpoint (3 handlers)

	stringSchema := "â‡¨ http server started on " + Schema + ":" + ServerPort

	stringLogin := gcolor.CyanCor("[File-debug] POST       ") + Login + YellowCor("                 --> Login(2 Handlers)")

	stringPing := gcolor.CyanCor("[File-debug] POST       ") + Ping + YellowCor("                  --> Ping(2 Handlers)")

	stringHello := gcolor.CyanCor("[File-debug] POST       ") + Hello + YellowCor("                 --> Hello(2 Handlers)")

	stringCreateUser := gcolor.CyanCor("[File-debug] POST       ") + CreateUser + YellowCor("                       --> CreateUser(2 Handlers)")

	stringUpload := gcolor.CyanCor("[File-debug] POST       ") + Upload + YellowCor("                --> Upload(2 Handlers)")

	stringDisableUser := gcolor.CyanCor("[File-debug] PUT        ") + DisableUser + YellowCor("               --> DisableUser(2 Handlers)")

	stringEnableUser := gcolor.CyanCor("[File-debug] PUT        ") + EnableUser + YellowCor("                --> EnableUser(2 Handlers)")

	stringDownload := gcolor.CyanCor("[File-debug] POST       ") + Download + YellowCor("              --> Download(2 Handlers)")

	//
	// Showing on the screen
	//
	gcolor.Green.Cprintln(stringSchema)

	fmt.Println(stringPing)

	fmt.Println("")

	fmt.Println(stringLogin)

	fmt.Println(stringHello)

	fmt.Println("")

	fmt.Println(stringCreateUser)

	fmt.Println(stringDisableUser)

	fmt.Println(stringEnableUser)

	fmt.Println("")

	fmt.Println(stringUpload)

	fmt.Println(stringDownload)

	gcolor.Yellow.Cprintln(SizeString)

}
